<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <h1>Welcome, {{ current_user.name }}!</h1>
        <div class="tabs">
            <button class="tablink" onclick="openTab(event, 'CharacterCreation')" id="defaultOpen">Character Creation</button>
            <button class="tablink" onclick="openTab(event, 'Admin')">Admin</button>
        </div>

        <div id="CharacterCreation" class="tabcontent">
            <h3>Character Creation Steps (D&D 5e)</h3>
            <ul>
                <!-- Steps will be populated by Flask -->
                {% for step in character_creation_steps %}
                <li>{{ step }}</li>
                {% endfor %}
            </ul>
        </div>

        <div id="Admin" class="tabcontent">
            <h3>Admin Page</h3>
            <p>Enter a REST endpoint URL to retrieve and display its structure.</p>
            <input type="text" id="restUrl" placeholder="Enter REST API URL">
            <button onclick="fetchStructure()">Get structure</button>
            <div id="treeView">
                <!-- Tree view will be populated here -->
            </div>

            <hr style="margin-top: 20px; margin-bottom: 20px;">

            <div>
                <h4>Process D&D Races Database</h4>
                <button id="processRacesBtn" onclick="startRaceProcessing()">Process Races from Open5E</button>
                <div id="progressBarContainer" style="width: 100%; background-color: #ddd; margin-top: 10px; display: none;">
                    <div id="progressBar" style="width: 0%; height: 30px; background-color: #4CAF50; text-align: center; line-height: 30px; color: white;">
                        0%
                    </div>
                </div>
                <div id="processStatus" style="margin-top: 10px;"></div>
            </div>

        </div>

        <a href="{{ url_for('logout') }}">Logout</a>
    </div>

    <script>
        let raceProcessIntervalId = null; // To store the interval ID for polling

        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablink");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        // Get the element with id="defaultOpen" and click on it
        document.getElementById("defaultOpen").click();

        async function fetchStructure() {
            const url = document.getElementById('restUrl').value;
            const treeView = document.getElementById('treeView');
            treeView.innerHTML = 'Loading...';

            if (!url) {
                treeView.innerHTML = 'Please enter a URL.';
                return;
            }

            try {
                // We'll use a new Flask endpoint to handle the backend fetching and processing
                const response = await fetch(`/admin/get_structure?url=${encodeURIComponent(url)}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                // Clear previous tree
                treeView.innerHTML = '';

                // Create and append the tree
                const ul = createTree(data, true); // Pass true for root level
                treeView.appendChild(ul);

            } catch (error) {
                treeView.innerHTML = `Error: ${error.message}`;
                console.error('Error fetching structure:', error);
            }
        }

        function createTree(data, isRoot = false) {
            const ul = document.createElement('ul');
            if (isRoot) {
                ul.className = 'tree-root';
            }

            for (const key in data) {
                const li = document.createElement('li');

                const keySpan = document.createElement('strong');
                keySpan.textContent = `${key}: `;
                li.appendChild(keySpan);

                const value = data[key];

                if (typeof value === 'object' && value !== null) {
                    if (Array.isArray(value)) {
                        // Special handling for 'results' array or any array of objects
                        if (value.every(item => typeof item === 'object' && item !== null && !Array.isArray(item))) {
                            const itemSummary = document.createElement('span');
                            itemSummary.className = 'array-summary';
                            itemSummary.textContent = `[Array of ${value.length} objects] `;
                            li.appendChild(itemSummary);

                            const expandButton = document.createElement('button');
                            expandButton.textContent = 'Expand';
                            expandButton.className = 'expand-btn';
                            li.appendChild(expandButton);

                            const subUl = document.createElement('ul');
                            subUl.className = 'collapsible-content';
                            subUl.style.display = 'none'; // Initially collapsed

                            value.forEach((item, index) => {
                                const itemLi = document.createElement('li');
                                const itemKeySpan = document.createElement('strong');
                                // Try to find a 'name' or 'id' for a more descriptive summary, otherwise use index
                                let itemTitle = item.name || item.id || `Item ${index + 1}`;
                                itemKeySpan.textContent = `${itemTitle}: `;
                                itemLi.appendChild(itemKeySpan);

                                const itemExpandButton = document.createElement('button');
                                itemExpandButton.textContent = 'Details';
                                itemExpandButton.className = 'expand-btn';
                                itemLi.appendChild(itemExpandButton);

                                const itemSubUl = createTree(item);
                                itemSubUl.className = 'collapsible-content';
                                itemSubUl.style.display = 'none';
                                itemLi.appendChild(itemSubUl);

                                itemExpandButton.onclick = () => {
                                    const isHidden = itemSubUl.style.display === 'none';
                                    itemSubUl.style.display = isHidden ? 'block' : 'none';
                                    itemExpandButton.textContent = isHidden ? 'Collapse' : 'Details';
                                };
                                subUl.appendChild(itemLi);
                            });
                            li.appendChild(subUl);

                            expandButton.onclick = () => {
                                const isHidden = subUl.style.display === 'none';
                                subUl.style.display = isHidden ? 'block' : 'none';
                                expandButton.textContent = isHidden ? 'Collapse' : 'Expand';
                            };

                        } else { // Array of simple types or mixed
                            const valueSpan = document.createElement('span');
                            valueSpan.textContent = `[Array (${value.length} items)]`;
                            li.appendChild(valueSpan);
                            // Optionally, could still expand simple arrays if needed
                            const subUl = createTree(value); // Recursive call for arrays
                            li.appendChild(subUl);
                        }
                    } else { // It's an object
                        const subUl = createTree(value);
                        li.appendChild(subUl);
                    }
                } else { // Simple value (string, number, boolean)
                    const valueSpan = document.createElement('span');
                    valueSpan.textContent = value;
                    li.appendChild(valueSpan);
                }
                ul.appendChild(li);
            }
            return ul;
        }

        // --- Race Processing Script ---
        async function startRaceProcessing() {
            const processBtn = document.getElementById('processRacesBtn');
            const progressBarContainer = document.getElementById('progressBarContainer');
            const progressBar = document.getElementById('progressBar');
            const processStatusDiv = document.getElementById('processStatus');

            processBtn.disabled = true;
            processStatusDiv.textContent = 'Initiating processing...';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            progressBarContainer.style.display = 'block';

            if (raceProcessIntervalId) {
                clearInterval(raceProcessIntervalId); // Clear any existing interval
            }

            try {
                const response = await fetch('/admin/run-race-processing', { method: 'POST' });
                const data = await response.json();

                if (response.ok) {
                    processStatusDiv.textContent = data.message || 'Processing started. Waiting for progress...';
                    // Start polling for status
                    raceProcessIntervalId = setInterval(getRaceProcessingStatus, 2000); // Poll every 2 seconds
                } else {
                    processStatusDiv.textContent = `Error: ${data.error || 'Unknown error starting process.'}`;
                    processBtn.disabled = false;
                    progressBarContainer.style.display = 'none';
                }
            } catch (error) {
                processStatusDiv.textContent = `Network or client-side error: ${error.message}`;
                processBtn.disabled = false;
                progressBarContainer.style.display = 'none';
                console.error('Error starting race processing:', error);
            }
        }

        async function getRaceProcessingStatus() {
            const processBtn = document.getElementById('processRacesBtn');
            const progressBarContainer = document.getElementById('progressBarContainer');
            const progressBar = document.getElementById('progressBar');
            const processStatusDiv = document.getElementById('processStatus');

            try {
                const response = await fetch('/admin/get-race-processing-status');
                if (!response.ok) {
                    // If status endpoint itself fails, show an error but keep polling for a bit
                    processStatusDiv.textContent = `Error fetching status: ${response.statusText}. Retrying...`;
                    console.error('Error fetching status:', response.statusText);
                    return;
                }
                const data = await response.json();

                processStatusDiv.textContent = data.message || 'Polling...';

                if (data.total > 0) {
                    const percentage = Math.round((data.current / data.total) * 100);
                    progressBar.style.width = `${percentage}%`;
                    progressBar.textContent = `${percentage}% (${data.current}/${data.total})`;
                } else if (data.status === 'running') {
                    // Still running but total might not be known yet (e.g. fetching list)
                    progressBar.style.width = '5%'; // Small indication of activity
                    progressBar.textContent = 'Processing...';
                }


                if (data.status === 'complete' || data.status === 'error') {
                    clearInterval(raceProcessIntervalId);
                    raceProcessIntervalId = null;
                    processBtn.disabled = false;
                    if (data.status === 'complete') {
                        processStatusDiv.textContent = data.message || 'Processing complete!';
                        progressBar.style.width = '100%';
                        progressBar.textContent = '100%';
                        if(data.output_file) {
                            processStatusDiv.innerHTML += `<br>Output file: ${data.output_file}`;
                        }
                    } else { // Error
                        processStatusDiv.textContent = `Error: ${data.message || data.error_details || 'Unknown error during processing.'}`;
                        progressBar.style.backgroundColor = 'red'; // Indicate error on progress bar
                    }
                } else if (data.status === 'idle' && !raceProcessIntervalId) {
                    // This case might happen if page is reloaded and status was idle
                    processBtn.disabled = false;
                    progressBarContainer.style.display = 'none';
                    processStatusDiv.textContent = 'Ready to process.';
                }


            } catch (error) {
                processStatusDiv.textContent = `Error polling status: ${error.message}. Polling stopped.`;
                console.error('Error polling race processing status:', error);
                clearInterval(raceProcessIntervalId);
                raceProcessIntervalId = null;
                processBtn.disabled = false;
                 progressBarContainer.style.display = 'none';
            }
        }
        // Initial check in case processing was ongoing from a previous interaction on this page load
        // or if the server restarted and status is now idle.
        // However, for simplicity, we'll rely on the user to click the button to start.
        // If you need to pick up an ongoing process, you'd call getRaceProcessingStatus() on page load
        // and potentially restart polling if status is 'running'.
        // For now, let's ensure the button is enabled if the initial state is idle.
        // document.addEventListener('DOMContentLoaded', () => {
        //     getRaceProcessingStatus(); // Check status on load to set initial button/UI state
        // });

    </script>
</body>
</html>
